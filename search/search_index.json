{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quickstart Guide","text":""},{"location":"#installation","title":"Installation","text":"<p>To install StateDict2PyTree, run:</p> <pre><code>pip install statedict2pytree\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>StateDict2PyTree provides two main ways to convert PyTorch state dicts to JAX pytrees:</p> <ol> <li>Using paths to chunked files</li> <li>Using in-memory structures</li> </ol>"},{"location":"#using-paths-to-chunked-files","title":"Using Paths to Chunked Files","text":"<p>This method is useful for large models that may not fit in memory.</p> <pre><code>import statedict2pytree as s2p\nfrom statedict2pytree.utils.utils_state_dict import chunkify_state_dict\nfrom statedict2pytree.utils.utils_pytree import chunkify_pytree\n\n# Chunkify your PyTorch state dict\nchunkify_state_dict(torch_state_dict, \"path/to/tmp/dir\")\n\n# Chunkify your JAX model\njax_model = create_your_jax_model()\nchunkify_pytree(jax_model, \"path/to/tmp/dir\")\n\n# Start the conversion server\ns2p.start_conversion_from_paths(\"path/to/tmp/dir\", \"path/to/tmp/dir\")\n\n# Cancel the server using CTRL+C. This will continue the code execution\n\n# Load model\n</code></pre>"},{"location":"#using-in-memory-structures","title":"Using In-Memory Structures","text":"<p>This method is suitable for smaller models that can fit in memory.</p> <pre><code>import statedict2pytree as s2p\n\njax_model = create_your_jax_model()\ntorch_state_dict = load_your_torch_state_dict()\n\ns2p.start_conversion_from_pytree_and_state_dict(jax_model, torch_state_dict)\n</code></pre> <p>After running either of these methods, you can access the conversion UI by opening a web browser and navigating to http://localhost:5500</p>"},{"location":"#advanced-usage","title":"Advanced Usage","text":"<p>For more advanced usage and API details, please refer to the API Reference.</p>"},{"location":"examples/","title":"Usage Examples","text":""},{"location":"examples/#converting-llama-3-model","title":"Converting LLaMA 3 Model","text":"<p>This example demonstrates how to convert the LLaMA 3 model from PyTorch to JAX: (see the <code>examples</code> directory on GitHub)</p> <pre><code>import json\nimport os\nimport tempfile\nimport jax\nimport torch\nfrom jaxonmodels.transformers.llama.llama3 import LLaMA\nfrom jaxonmodels.transformers.llama.model_args import LLaMAModelArgs\nfrom loguru import logger\nfrom statedict2pytree.statedict2pytree import start_conversion_from_paths\nfrom statedict2pytree.utils.utils_pytree import chunkify_pytree, serialize_pytree_chunks\nfrom statedict2pytree.utils.utils_state_dict import chunkify_state_dict\nfrom tqdm import tqdm\n\ndef main():\n    with tempfile.TemporaryDirectory() as tmp:\n        logger.info(\"Loading state dict...\")\n        state_dict = torch.load(\"Meta-Llama-3-8B/consolidated.00.pth\")\n        logger.info(\"Done. Converting to float16...\")\n        for key in tqdm(state_dict.keys()):\n            if torch.is_tensor(state_dict[key]):\n                state_dict[key] = state_dict[key].to(torch.float16)\n        logger.info(\"Done. Chunkifying state dict...\")\n        chunkify_state_dict(state_dict, tmp)\n        logger.info(\"Done. Deleting state dict...\")\n        del state_dict\n        with open(\"Meta-Llama-3-8B/params.json\", \"r\") as f:\n            params = json.load(f)\n        model_args = LLaMAModelArgs(**params)\n        model_args.precision = \"quarter\"\n        key = jax.random.PRNGKey(21)\n        logger.info(\"Creating JAX model...\")\n        model = LLaMA(model_args, key=key)\n        logger.info(\"Done. Chunkifying PyTree...\")\n        paths = chunkify_pytree(model, tmp)\n        logger.info(\"Done. Starting server...\")\n        start_conversion_from_paths(tmp, tmp)\n        paths = os.listdir(f\"{tmp}/pytree\")\n        tree_paths = []\n        for p in paths:\n            tree_paths.append(f\"{tmp}/pytree/\" + p)\n        logger.info(\"SERIALIZING PYTREE\")\n        serialize_pytree_chunks(model, tree_paths, \"model.eqx\")\n        logger.info(\"Done.\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"examples/#converting-resnet18-model","title":"Converting ResNet18 Model","text":"<p>This example shows how to convert a ResNet18 model from PyTorch to JAX:</p> <p>(see the <code>examples</code> directory on GitHub)</p> <pre><code>import jax\nimport statedict2pytree as s2p\nfrom resnet_model import resnet18\nfrom torchvision.models import resnet18 as t_resnet18, ResNet18_Weights\n\ndef convert_resnet():\n    resnet_jax = resnet18(key=jax.random.PRNGKey(33), make_with_state=False)\n    resnet_torch = t_resnet18(weights=ResNet18_Weights.DEFAULT)\n    state_dict = resnet_torch.state_dict()\n    s2p.start_conversion_from_pytree_and_state_dict(resnet_jax, state_dict)\n\nif __name__ == \"__main__\":\n    convert_resnet()\n</code></pre>"},{"location":"statedict2pytree/","title":"StateDict to PyTree Converter","text":"<p>This module provides the core functionality for converting PyTorch state dictionaries to JAX pytrees.</p>"},{"location":"statedict2pytree/#main-conversion-functions","title":"Main Conversion Functions","text":""},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.autoconvert_from_paths","title":"<code>autoconvert_from_paths(chunkified_pytree_path, chunkified_state_dict_path)</code>","text":"<p>Automatically convert PyTorch state dict to JAX pytree using file paths.</p> <p>To \"make\" the paths, use <code>statedict2pytree.utils.utils_state_dict.chunkify_state_dict</code>. <code>statedict2pytree.utils.utils_pytree.chunkify_pytree</code>.</p> <p>Parameters:</p> Name Type Description Default <code>chunkified_pytree_path</code> <code>ChunkifiedPytreePath</code> <p>Path to the JAX pytree</p> required <code>chunkified_state_dict_path</code> <code>ChunkifiedStatedictPath</code> <p>Path to the</p> required Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def autoconvert_from_paths(\n    chunkified_pytree_path: ChunkifiedPytreePath,\n    chunkified_state_dict_path: ChunkifiedStatedictPath,\n):\n    \"\"\"\n    Automatically convert PyTorch state dict to JAX pytree using file paths.\n\n    To \"make\" the paths, use\n    `statedict2pytree.utils.utils_state_dict.chunkify_state_dict`.\n    `statedict2pytree.utils.utils_pytree.chunkify_pytree`.\n\n    Args:\n        chunkified_pytree_path (ChunkifiedPytreePath): Path to the JAX pytree\n        pickle file.\n        chunkified_state_dict_path (ChunkifiedStatedictPath): Path to the\n        PyTorch state dict pickle file.\n    \"\"\"\n    with open(\n        str(pathlib.Path(chunkified_pytree_path.path) / \"jax_fields.pkl\"), \"rb\"\n    ) as f:\n        jax_fields = pickle.load(f)\n\n    with open(\n        str(pathlib.Path(chunkified_state_dict_path.path) / \"torch_fields.pkl\"), \"rb\"\n    ) as f:\n        torch_fields = pickle.load(f)\n    convert_from_path(\n        jax_fields, torch_fields, chunkified_pytree_path, chunkified_state_dict_path\n    )\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.autoconvert_state_dict_to_pytree","title":"<code>autoconvert_state_dict_to_pytree(pytree, state_dict)</code>","text":"<p>Automatically convert a PyTorch state dict to a JAX pytree.</p> <p>Parameters:</p> Name Type Description Default <code>pytree</code> <code>PyTree</code> <p>The target JAX pytree structure.</p> required <code>state_dict</code> <code>dict</code> <p>The source PyTorch state dict.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[PyTree, State]</code> <p>A tuple containing the converted pytree and its associated state.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def autoconvert_state_dict_to_pytree(\n    pytree: PyTree, state_dict: dict\n) -&gt; tuple[PyTree, eqx.nn.State]:\n    \"\"\"\n    Automatically convert a PyTorch state dict to a JAX pytree.\n\n    Args:\n        pytree (PyTree): The target JAX pytree structure.\n        state_dict (dict): The source PyTorch state dict.\n\n    Returns:\n        tuple: A tuple containing the converted pytree and its associated state.\n    \"\"\"\n    jax_fields = pytree_to_fields(pytree)\n    torch_fields = state_dict_to_fields(state_dict)\n\n    for k, v in state_dict.items():\n        state_dict[k] = v.numpy()\n    return convert_from_pytree_and_state_dict(\n        jax_fields, torch_fields, pytree, state_dict\n    )\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.convert_from_path","title":"<code>convert_from_path(jax_fields, torch_fields, chunkified_pytree_path, chunkified_statedict_path)</code>","text":"<p>Convert PyTorch state dict to JAX pytree using file paths and field mappings.</p> <p>Parameters:</p> Name Type Description Default <code>jax_fields</code> <code>list[JaxField]</code> <p>List of JAX fields.</p> required <code>torch_fields</code> <code>list[TorchField]</code> <p>List of PyTorch fields.</p> required <code>chunkified_pytree_path</code> <code>ChunkifiedPytreePath</code> <p>Path to the</p> required <code>chunkified_statedict_path</code> <code>ChunkifiedStatedictPath</code> <p>Path to the</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If fields have incompatible shapes.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def convert_from_path(\n    jax_fields: list[JaxField],\n    torch_fields: list[TorchField],\n    chunkified_pytree_path: ChunkifiedPytreePath,\n    chunkified_statedict_path: ChunkifiedStatedictPath,\n):\n    \"\"\"\n    Convert PyTorch state dict to JAX pytree using file paths and field mappings.\n\n    Args:\n        jax_fields (list[JaxField]): List of JAX fields.\n        torch_fields (list[TorchField]): List of PyTorch fields.\n        chunkified_pytree_path (ChunkifiedPytreePath): Path to the\n        JAX pytree directory.\n        chunkified_statedict_path (ChunkifiedStatedictPath): Path to the\n        PyTorch state dict directory.\n\n    Raises:\n        ValueError: If fields have incompatible shapes.\n    \"\"\"\n    j_path = pathlib.Path(chunkified_pytree_path.path)\n    t_path = pathlib.Path(chunkified_statedict_path.path)\n\n    for jax_field, torch_field in tqdm(zip(jax_fields, torch_fields)):\n        if torch_field.skip:\n            continue\n        if not can_reshape(jax_field.shape, torch_field.shape):\n            raise ValueError(\n                \"Fields have incompatible shapes!\"\n                f\"{jax_field.shape=} != {torch_field.shape=}\"\n            )\n        pt_path = pathlib.Path(j_path) / \"pytree\" / jax_field.path\n        sd_path = pathlib.Path(t_path) / \"state_dict\" / torch_field.path\n\n        if pt_path.exists():\n            os.remove(pt_path)\n        np.save(pt_path, np.load(str(sd_path) + \".npy\"))\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.convert_from_pytree_and_state_dict","title":"<code>convert_from_pytree_and_state_dict(jax_fields, torch_fields, pytree, state_dict)</code>","text":"<p>Convert PyTorch state dict to JAX pytree using in-memory structures and field mappings.</p> <p>Parameters:</p> Name Type Description Default <code>jax_fields</code> <code>list[JaxField]</code> <p>List of JAX fields.</p> required <code>torch_fields</code> <code>list[TorchField]</code> <p>List of PyTorch fields.</p> required <code>pytree</code> <code>PyTree</code> <p>The target JAX pytree structure.</p> required <code>state_dict</code> <code>dict[str, ndarray]</code> <p>The source PyTorch state dict.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[PyTree, State]</code> <p>A tuple containing the converted pytree and its associated state.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fields have incompatible shapes.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def convert_from_pytree_and_state_dict(\n    jax_fields: list[JaxField],\n    torch_fields: list[TorchField],\n    pytree: PyTree,\n    state_dict: dict[str, np.ndarray],\n) -&gt; tuple[PyTree, eqx.nn.State]:\n    \"\"\"\n    Convert PyTorch state dict to JAX pytree using\n    in-memory structures and field mappings.\n\n    Args:\n        jax_fields (list[JaxField]): List of JAX fields.\n        torch_fields (list[TorchField]): List of PyTorch fields.\n        pytree (PyTree): The target JAX pytree structure.\n        state_dict (dict[str, np.ndarray]): The source PyTorch state dict.\n\n    Returns:\n        tuple: A tuple containing the converted pytree and its associated state.\n\n    Raises:\n        ValueError: If fields have incompatible shapes.\n    \"\"\"\n    identity = lambda *args, **kwargs: pytree\n    model, state = eqx.nn.make_with_state(identity)()\n    state_paths: list[tuple[JaxField, TorchField]] = []\n    for i in range(len(jax_fields)):\n        torch_field = torch_fields[i]\n        jax_field = jax_fields[i]\n        if torch_field.skip:\n            continue\n        if not can_reshape(jax_field.shape, torch_field.shape):\n            raise ValueError(\n                \"Fields have incompatible shapes! \"\n                f\"{jax_field.shape=} != {torch_field.shape=}\"\n            )\n        path = jax_field.path.split(\".\")[1:]\n        if \"StateIndex\" in jax_field.type:\n            state_paths.append((jax_field, torch_field))\n\n        else:\n            where = ft.partial(get_node, targets=path)\n            if where(model) is not None:\n                model = eqx.tree_at(\n                    where,\n                    model,\n                    state_dict[torch_field.path].reshape(jax_field.shape),\n                )\n    result: dict[str, list[TorchField]] = {}\n    for tuple_item in state_paths:\n        path_prefix = tuple_item[0].path.split(\".\")[1:-1]\n        prefix_key = \".\".join(path_prefix)\n        if prefix_key not in result:\n            result[prefix_key] = []\n        result[prefix_key].append(tuple_item[1])\n\n    for key in result:\n        state_index = get_node(model, key.split(\".\"))\n        if state_index is not None:\n            to_replace_tuple = tuple([state_dict[i.path] for i in result[key]])\n            state = state.set(state_index, to_replace_tuple)\n    return model, state\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.index","title":"<code>index()</code>","text":"<p>Serve the index.html file from the client's public directory.</p> <p>Returns:</p> Type Description <p>The contents of index.html file.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>@app.route(\"/\", methods=[\"GET\"])\ndef index():\n    \"\"\"\n    Serve the index.html file from the client's public directory.\n\n    Returns:\n        The contents of index.html file.\n    \"\"\"\n    return flask.send_from_directory(\"../client/public\", \"index.html\")\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.make_anthropic_request","title":"<code>make_anthropic_request()</code>","text":"<p>Make a request to the Anthropic API using the provided content and model.</p> <p>Returns:</p> Type Description <p>flask.Response: JSON response containing the API response or an error message.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If required keys are missing in the request data.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>@app.post(\"/anthropic\")\ndef make_anthropic_request():\n    \"\"\"\n    Make a request to the Anthropic API using the provided content and model.\n\n    Returns:\n        flask.Response: JSON response containing the API response or an error message.\n\n    Raises:\n        KeyError: If required keys are missing in the request data.\n    \"\"\"\n    api_key = os.getenv(\"ANTHROPIC_API_KEY\", None)\n    if api_key is None:\n        return {\"error\": \"ANTHROPIC_API_KEY not set in env vars!\"}\n\n    request_data = flask.request.json\n    if request_data is None:\n        return flask.jsonify({\"error\": \"No data received\"})\n    if \"content\" not in request_data:\n        return flask.jsonify({\"error\": \"No data received\"})\n\n    if \"model\" not in request_data:\n        return flask.jsonify({\"error\": \"There was no model provided\"})\n\n    content = request_data[\"content\"]\n\n    anthropic_model: Optional[str] = None\n\n    match request_data[\"model\"]:\n        case \"haiku\":\n            anthropic_model = \"claude-3-haiku-20240307\"\n        case \"opus\":\n            anthropic_model = \"claude-3-opus-20240229\"\n        case \"sonnet\":\n            anthropic_model = \"claude-3-sonnet-20240229\"\n    if not anthropic_model:\n        return flask.jsonify({\"error\": \"No model provided\"})\n\n    client = anthropic.Anthropic(api_key=api_key)\n    message = client.messages.create(\n        model=anthropic_model,\n        max_tokens=4096,\n        messages=[{\"role\": \"user\", \"content\": content}],\n    )\n\n    return json.dumps({\"content\": str(message.content[0].text)})  # pyright: ignore\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.start_conversion_from_paths","title":"<code>start_conversion_from_paths(pytree_path, state_dict_path)</code>","text":"<p>Initialize the conversion process using file paths and start the Flask server.</p> <p>Parameters:</p> Name Type Description Default <code>pytree_path</code> <code>str</code> <p>Path to the JAX pytree directory.</p> required <code>state_dict_path</code> <code>str</code> <p>Path to the PyTorch state dict directory.</p> required Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def start_conversion_from_paths(pytree_path: str, state_dict_path: str):\n    \"\"\"\n    Initialize the conversion process using file paths and start the Flask server.\n\n    Args:\n        pytree_path (str): Path to the JAX pytree directory.\n        state_dict_path (str): Path to the PyTorch state dict directory.\n    \"\"\"\n    global PYTREE_PATH, STATE_DICT_PATH\n    PYTREE_PATH = ChunkifiedPytreePath(path=pytree_path)\n    STATE_DICT_PATH = ChunkifiedStatedictPath(path=state_dict_path)\n    _run_server()\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.start_conversion_from_pytree_and_state_dict","title":"<code>start_conversion_from_pytree_and_state_dict(pytree, state_dict)</code>","text":"<p>Initialize the conversion process using in-memory structures and start the Flask server.</p> <p>Parameters:</p> Name Type Description Default <code>pytree</code> <code>PyTree</code> <p>The target JAX pytree structure.</p> required <code>state_dict</code> <code>dict[str, Tensor]</code> <p>The source PyTorch state dict.</p> required Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def start_conversion_from_pytree_and_state_dict(\n    pytree: PyTree, state_dict: dict[str, torch.Tensor]\n):\n    \"\"\"\n    Initialize the conversion process using in-memory structures and\n    start the Flask server.\n\n    Args:\n        pytree (PyTree): The target JAX pytree structure.\n        state_dict (dict[str, torch.Tensor]): The source PyTorch state dict.\n    \"\"\"\n    global PYTREE, STATE_DICT\n    PYTREE = pytree\n    STATE_DICT = dict()\n\n    for k, v in state_dict.items():\n        STATE_DICT[k] = v.numpy()\n    _run_server()\n</code></pre>"},{"location":"statedict2pytree/#server-initialization-functions","title":"Server Initialization Functions","text":""},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.autoconvert_from_paths","title":"<code>autoconvert_from_paths(chunkified_pytree_path, chunkified_state_dict_path)</code>","text":"<p>Automatically convert PyTorch state dict to JAX pytree using file paths.</p> <p>To \"make\" the paths, use <code>statedict2pytree.utils.utils_state_dict.chunkify_state_dict</code>. <code>statedict2pytree.utils.utils_pytree.chunkify_pytree</code>.</p> <p>Parameters:</p> Name Type Description Default <code>chunkified_pytree_path</code> <code>ChunkifiedPytreePath</code> <p>Path to the JAX pytree</p> required <code>chunkified_state_dict_path</code> <code>ChunkifiedStatedictPath</code> <p>Path to the</p> required Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def autoconvert_from_paths(\n    chunkified_pytree_path: ChunkifiedPytreePath,\n    chunkified_state_dict_path: ChunkifiedStatedictPath,\n):\n    \"\"\"\n    Automatically convert PyTorch state dict to JAX pytree using file paths.\n\n    To \"make\" the paths, use\n    `statedict2pytree.utils.utils_state_dict.chunkify_state_dict`.\n    `statedict2pytree.utils.utils_pytree.chunkify_pytree`.\n\n    Args:\n        chunkified_pytree_path (ChunkifiedPytreePath): Path to the JAX pytree\n        pickle file.\n        chunkified_state_dict_path (ChunkifiedStatedictPath): Path to the\n        PyTorch state dict pickle file.\n    \"\"\"\n    with open(\n        str(pathlib.Path(chunkified_pytree_path.path) / \"jax_fields.pkl\"), \"rb\"\n    ) as f:\n        jax_fields = pickle.load(f)\n\n    with open(\n        str(pathlib.Path(chunkified_state_dict_path.path) / \"torch_fields.pkl\"), \"rb\"\n    ) as f:\n        torch_fields = pickle.load(f)\n    convert_from_path(\n        jax_fields, torch_fields, chunkified_pytree_path, chunkified_state_dict_path\n    )\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.autoconvert_state_dict_to_pytree","title":"<code>autoconvert_state_dict_to_pytree(pytree, state_dict)</code>","text":"<p>Automatically convert a PyTorch state dict to a JAX pytree.</p> <p>Parameters:</p> Name Type Description Default <code>pytree</code> <code>PyTree</code> <p>The target JAX pytree structure.</p> required <code>state_dict</code> <code>dict</code> <p>The source PyTorch state dict.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[PyTree, State]</code> <p>A tuple containing the converted pytree and its associated state.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def autoconvert_state_dict_to_pytree(\n    pytree: PyTree, state_dict: dict\n) -&gt; tuple[PyTree, eqx.nn.State]:\n    \"\"\"\n    Automatically convert a PyTorch state dict to a JAX pytree.\n\n    Args:\n        pytree (PyTree): The target JAX pytree structure.\n        state_dict (dict): The source PyTorch state dict.\n\n    Returns:\n        tuple: A tuple containing the converted pytree and its associated state.\n    \"\"\"\n    jax_fields = pytree_to_fields(pytree)\n    torch_fields = state_dict_to_fields(state_dict)\n\n    for k, v in state_dict.items():\n        state_dict[k] = v.numpy()\n    return convert_from_pytree_and_state_dict(\n        jax_fields, torch_fields, pytree, state_dict\n    )\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.convert_from_path","title":"<code>convert_from_path(jax_fields, torch_fields, chunkified_pytree_path, chunkified_statedict_path)</code>","text":"<p>Convert PyTorch state dict to JAX pytree using file paths and field mappings.</p> <p>Parameters:</p> Name Type Description Default <code>jax_fields</code> <code>list[JaxField]</code> <p>List of JAX fields.</p> required <code>torch_fields</code> <code>list[TorchField]</code> <p>List of PyTorch fields.</p> required <code>chunkified_pytree_path</code> <code>ChunkifiedPytreePath</code> <p>Path to the</p> required <code>chunkified_statedict_path</code> <code>ChunkifiedStatedictPath</code> <p>Path to the</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If fields have incompatible shapes.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def convert_from_path(\n    jax_fields: list[JaxField],\n    torch_fields: list[TorchField],\n    chunkified_pytree_path: ChunkifiedPytreePath,\n    chunkified_statedict_path: ChunkifiedStatedictPath,\n):\n    \"\"\"\n    Convert PyTorch state dict to JAX pytree using file paths and field mappings.\n\n    Args:\n        jax_fields (list[JaxField]): List of JAX fields.\n        torch_fields (list[TorchField]): List of PyTorch fields.\n        chunkified_pytree_path (ChunkifiedPytreePath): Path to the\n        JAX pytree directory.\n        chunkified_statedict_path (ChunkifiedStatedictPath): Path to the\n        PyTorch state dict directory.\n\n    Raises:\n        ValueError: If fields have incompatible shapes.\n    \"\"\"\n    j_path = pathlib.Path(chunkified_pytree_path.path)\n    t_path = pathlib.Path(chunkified_statedict_path.path)\n\n    for jax_field, torch_field in tqdm(zip(jax_fields, torch_fields)):\n        if torch_field.skip:\n            continue\n        if not can_reshape(jax_field.shape, torch_field.shape):\n            raise ValueError(\n                \"Fields have incompatible shapes!\"\n                f\"{jax_field.shape=} != {torch_field.shape=}\"\n            )\n        pt_path = pathlib.Path(j_path) / \"pytree\" / jax_field.path\n        sd_path = pathlib.Path(t_path) / \"state_dict\" / torch_field.path\n\n        if pt_path.exists():\n            os.remove(pt_path)\n        np.save(pt_path, np.load(str(sd_path) + \".npy\"))\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.convert_from_pytree_and_state_dict","title":"<code>convert_from_pytree_and_state_dict(jax_fields, torch_fields, pytree, state_dict)</code>","text":"<p>Convert PyTorch state dict to JAX pytree using in-memory structures and field mappings.</p> <p>Parameters:</p> Name Type Description Default <code>jax_fields</code> <code>list[JaxField]</code> <p>List of JAX fields.</p> required <code>torch_fields</code> <code>list[TorchField]</code> <p>List of PyTorch fields.</p> required <code>pytree</code> <code>PyTree</code> <p>The target JAX pytree structure.</p> required <code>state_dict</code> <code>dict[str, ndarray]</code> <p>The source PyTorch state dict.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[PyTree, State]</code> <p>A tuple containing the converted pytree and its associated state.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fields have incompatible shapes.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def convert_from_pytree_and_state_dict(\n    jax_fields: list[JaxField],\n    torch_fields: list[TorchField],\n    pytree: PyTree,\n    state_dict: dict[str, np.ndarray],\n) -&gt; tuple[PyTree, eqx.nn.State]:\n    \"\"\"\n    Convert PyTorch state dict to JAX pytree using\n    in-memory structures and field mappings.\n\n    Args:\n        jax_fields (list[JaxField]): List of JAX fields.\n        torch_fields (list[TorchField]): List of PyTorch fields.\n        pytree (PyTree): The target JAX pytree structure.\n        state_dict (dict[str, np.ndarray]): The source PyTorch state dict.\n\n    Returns:\n        tuple: A tuple containing the converted pytree and its associated state.\n\n    Raises:\n        ValueError: If fields have incompatible shapes.\n    \"\"\"\n    identity = lambda *args, **kwargs: pytree\n    model, state = eqx.nn.make_with_state(identity)()\n    state_paths: list[tuple[JaxField, TorchField]] = []\n    for i in range(len(jax_fields)):\n        torch_field = torch_fields[i]\n        jax_field = jax_fields[i]\n        if torch_field.skip:\n            continue\n        if not can_reshape(jax_field.shape, torch_field.shape):\n            raise ValueError(\n                \"Fields have incompatible shapes! \"\n                f\"{jax_field.shape=} != {torch_field.shape=}\"\n            )\n        path = jax_field.path.split(\".\")[1:]\n        if \"StateIndex\" in jax_field.type:\n            state_paths.append((jax_field, torch_field))\n\n        else:\n            where = ft.partial(get_node, targets=path)\n            if where(model) is not None:\n                model = eqx.tree_at(\n                    where,\n                    model,\n                    state_dict[torch_field.path].reshape(jax_field.shape),\n                )\n    result: dict[str, list[TorchField]] = {}\n    for tuple_item in state_paths:\n        path_prefix = tuple_item[0].path.split(\".\")[1:-1]\n        prefix_key = \".\".join(path_prefix)\n        if prefix_key not in result:\n            result[prefix_key] = []\n        result[prefix_key].append(tuple_item[1])\n\n    for key in result:\n        state_index = get_node(model, key.split(\".\"))\n        if state_index is not None:\n            to_replace_tuple = tuple([state_dict[i.path] for i in result[key]])\n            state = state.set(state_index, to_replace_tuple)\n    return model, state\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.index","title":"<code>index()</code>","text":"<p>Serve the index.html file from the client's public directory.</p> <p>Returns:</p> Type Description <p>The contents of index.html file.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>@app.route(\"/\", methods=[\"GET\"])\ndef index():\n    \"\"\"\n    Serve the index.html file from the client's public directory.\n\n    Returns:\n        The contents of index.html file.\n    \"\"\"\n    return flask.send_from_directory(\"../client/public\", \"index.html\")\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.make_anthropic_request","title":"<code>make_anthropic_request()</code>","text":"<p>Make a request to the Anthropic API using the provided content and model.</p> <p>Returns:</p> Type Description <p>flask.Response: JSON response containing the API response or an error message.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If required keys are missing in the request data.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>@app.post(\"/anthropic\")\ndef make_anthropic_request():\n    \"\"\"\n    Make a request to the Anthropic API using the provided content and model.\n\n    Returns:\n        flask.Response: JSON response containing the API response or an error message.\n\n    Raises:\n        KeyError: If required keys are missing in the request data.\n    \"\"\"\n    api_key = os.getenv(\"ANTHROPIC_API_KEY\", None)\n    if api_key is None:\n        return {\"error\": \"ANTHROPIC_API_KEY not set in env vars!\"}\n\n    request_data = flask.request.json\n    if request_data is None:\n        return flask.jsonify({\"error\": \"No data received\"})\n    if \"content\" not in request_data:\n        return flask.jsonify({\"error\": \"No data received\"})\n\n    if \"model\" not in request_data:\n        return flask.jsonify({\"error\": \"There was no model provided\"})\n\n    content = request_data[\"content\"]\n\n    anthropic_model: Optional[str] = None\n\n    match request_data[\"model\"]:\n        case \"haiku\":\n            anthropic_model = \"claude-3-haiku-20240307\"\n        case \"opus\":\n            anthropic_model = \"claude-3-opus-20240229\"\n        case \"sonnet\":\n            anthropic_model = \"claude-3-sonnet-20240229\"\n    if not anthropic_model:\n        return flask.jsonify({\"error\": \"No model provided\"})\n\n    client = anthropic.Anthropic(api_key=api_key)\n    message = client.messages.create(\n        model=anthropic_model,\n        max_tokens=4096,\n        messages=[{\"role\": \"user\", \"content\": content}],\n    )\n\n    return json.dumps({\"content\": str(message.content[0].text)})  # pyright: ignore\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.start_conversion_from_paths","title":"<code>start_conversion_from_paths(pytree_path, state_dict_path)</code>","text":"<p>Initialize the conversion process using file paths and start the Flask server.</p> <p>Parameters:</p> Name Type Description Default <code>pytree_path</code> <code>str</code> <p>Path to the JAX pytree directory.</p> required <code>state_dict_path</code> <code>str</code> <p>Path to the PyTorch state dict directory.</p> required Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def start_conversion_from_paths(pytree_path: str, state_dict_path: str):\n    \"\"\"\n    Initialize the conversion process using file paths and start the Flask server.\n\n    Args:\n        pytree_path (str): Path to the JAX pytree directory.\n        state_dict_path (str): Path to the PyTorch state dict directory.\n    \"\"\"\n    global PYTREE_PATH, STATE_DICT_PATH\n    PYTREE_PATH = ChunkifiedPytreePath(path=pytree_path)\n    STATE_DICT_PATH = ChunkifiedStatedictPath(path=state_dict_path)\n    _run_server()\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.start_conversion_from_pytree_and_state_dict","title":"<code>start_conversion_from_pytree_and_state_dict(pytree, state_dict)</code>","text":"<p>Initialize the conversion process using in-memory structures and start the Flask server.</p> <p>Parameters:</p> Name Type Description Default <code>pytree</code> <code>PyTree</code> <p>The target JAX pytree structure.</p> required <code>state_dict</code> <code>dict[str, Tensor]</code> <p>The source PyTorch state dict.</p> required Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def start_conversion_from_pytree_and_state_dict(\n    pytree: PyTree, state_dict: dict[str, torch.Tensor]\n):\n    \"\"\"\n    Initialize the conversion process using in-memory structures and\n    start the Flask server.\n\n    Args:\n        pytree (PyTree): The target JAX pytree structure.\n        state_dict (dict[str, torch.Tensor]): The source PyTorch state dict.\n    \"\"\"\n    global PYTREE, STATE_DICT\n    PYTREE = pytree\n    STATE_DICT = dict()\n\n    for k, v in state_dict.items():\n        STATE_DICT[k] = v.numpy()\n    _run_server()\n</code></pre>"},{"location":"statedict2pytree/#flask-server-routes","title":"Flask Server Routes","text":""},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.autoconvert_from_paths","title":"<code>autoconvert_from_paths(chunkified_pytree_path, chunkified_state_dict_path)</code>","text":"<p>Automatically convert PyTorch state dict to JAX pytree using file paths.</p> <p>To \"make\" the paths, use <code>statedict2pytree.utils.utils_state_dict.chunkify_state_dict</code>. <code>statedict2pytree.utils.utils_pytree.chunkify_pytree</code>.</p> <p>Parameters:</p> Name Type Description Default <code>chunkified_pytree_path</code> <code>ChunkifiedPytreePath</code> <p>Path to the JAX pytree</p> required <code>chunkified_state_dict_path</code> <code>ChunkifiedStatedictPath</code> <p>Path to the</p> required Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def autoconvert_from_paths(\n    chunkified_pytree_path: ChunkifiedPytreePath,\n    chunkified_state_dict_path: ChunkifiedStatedictPath,\n):\n    \"\"\"\n    Automatically convert PyTorch state dict to JAX pytree using file paths.\n\n    To \"make\" the paths, use\n    `statedict2pytree.utils.utils_state_dict.chunkify_state_dict`.\n    `statedict2pytree.utils.utils_pytree.chunkify_pytree`.\n\n    Args:\n        chunkified_pytree_path (ChunkifiedPytreePath): Path to the JAX pytree\n        pickle file.\n        chunkified_state_dict_path (ChunkifiedStatedictPath): Path to the\n        PyTorch state dict pickle file.\n    \"\"\"\n    with open(\n        str(pathlib.Path(chunkified_pytree_path.path) / \"jax_fields.pkl\"), \"rb\"\n    ) as f:\n        jax_fields = pickle.load(f)\n\n    with open(\n        str(pathlib.Path(chunkified_state_dict_path.path) / \"torch_fields.pkl\"), \"rb\"\n    ) as f:\n        torch_fields = pickle.load(f)\n    convert_from_path(\n        jax_fields, torch_fields, chunkified_pytree_path, chunkified_state_dict_path\n    )\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.autoconvert_state_dict_to_pytree","title":"<code>autoconvert_state_dict_to_pytree(pytree, state_dict)</code>","text":"<p>Automatically convert a PyTorch state dict to a JAX pytree.</p> <p>Parameters:</p> Name Type Description Default <code>pytree</code> <code>PyTree</code> <p>The target JAX pytree structure.</p> required <code>state_dict</code> <code>dict</code> <p>The source PyTorch state dict.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[PyTree, State]</code> <p>A tuple containing the converted pytree and its associated state.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def autoconvert_state_dict_to_pytree(\n    pytree: PyTree, state_dict: dict\n) -&gt; tuple[PyTree, eqx.nn.State]:\n    \"\"\"\n    Automatically convert a PyTorch state dict to a JAX pytree.\n\n    Args:\n        pytree (PyTree): The target JAX pytree structure.\n        state_dict (dict): The source PyTorch state dict.\n\n    Returns:\n        tuple: A tuple containing the converted pytree and its associated state.\n    \"\"\"\n    jax_fields = pytree_to_fields(pytree)\n    torch_fields = state_dict_to_fields(state_dict)\n\n    for k, v in state_dict.items():\n        state_dict[k] = v.numpy()\n    return convert_from_pytree_and_state_dict(\n        jax_fields, torch_fields, pytree, state_dict\n    )\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.convert_from_path","title":"<code>convert_from_path(jax_fields, torch_fields, chunkified_pytree_path, chunkified_statedict_path)</code>","text":"<p>Convert PyTorch state dict to JAX pytree using file paths and field mappings.</p> <p>Parameters:</p> Name Type Description Default <code>jax_fields</code> <code>list[JaxField]</code> <p>List of JAX fields.</p> required <code>torch_fields</code> <code>list[TorchField]</code> <p>List of PyTorch fields.</p> required <code>chunkified_pytree_path</code> <code>ChunkifiedPytreePath</code> <p>Path to the</p> required <code>chunkified_statedict_path</code> <code>ChunkifiedStatedictPath</code> <p>Path to the</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If fields have incompatible shapes.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def convert_from_path(\n    jax_fields: list[JaxField],\n    torch_fields: list[TorchField],\n    chunkified_pytree_path: ChunkifiedPytreePath,\n    chunkified_statedict_path: ChunkifiedStatedictPath,\n):\n    \"\"\"\n    Convert PyTorch state dict to JAX pytree using file paths and field mappings.\n\n    Args:\n        jax_fields (list[JaxField]): List of JAX fields.\n        torch_fields (list[TorchField]): List of PyTorch fields.\n        chunkified_pytree_path (ChunkifiedPytreePath): Path to the\n        JAX pytree directory.\n        chunkified_statedict_path (ChunkifiedStatedictPath): Path to the\n        PyTorch state dict directory.\n\n    Raises:\n        ValueError: If fields have incompatible shapes.\n    \"\"\"\n    j_path = pathlib.Path(chunkified_pytree_path.path)\n    t_path = pathlib.Path(chunkified_statedict_path.path)\n\n    for jax_field, torch_field in tqdm(zip(jax_fields, torch_fields)):\n        if torch_field.skip:\n            continue\n        if not can_reshape(jax_field.shape, torch_field.shape):\n            raise ValueError(\n                \"Fields have incompatible shapes!\"\n                f\"{jax_field.shape=} != {torch_field.shape=}\"\n            )\n        pt_path = pathlib.Path(j_path) / \"pytree\" / jax_field.path\n        sd_path = pathlib.Path(t_path) / \"state_dict\" / torch_field.path\n\n        if pt_path.exists():\n            os.remove(pt_path)\n        np.save(pt_path, np.load(str(sd_path) + \".npy\"))\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.convert_from_pytree_and_state_dict","title":"<code>convert_from_pytree_and_state_dict(jax_fields, torch_fields, pytree, state_dict)</code>","text":"<p>Convert PyTorch state dict to JAX pytree using in-memory structures and field mappings.</p> <p>Parameters:</p> Name Type Description Default <code>jax_fields</code> <code>list[JaxField]</code> <p>List of JAX fields.</p> required <code>torch_fields</code> <code>list[TorchField]</code> <p>List of PyTorch fields.</p> required <code>pytree</code> <code>PyTree</code> <p>The target JAX pytree structure.</p> required <code>state_dict</code> <code>dict[str, ndarray]</code> <p>The source PyTorch state dict.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>tuple[PyTree, State]</code> <p>A tuple containing the converted pytree and its associated state.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fields have incompatible shapes.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def convert_from_pytree_and_state_dict(\n    jax_fields: list[JaxField],\n    torch_fields: list[TorchField],\n    pytree: PyTree,\n    state_dict: dict[str, np.ndarray],\n) -&gt; tuple[PyTree, eqx.nn.State]:\n    \"\"\"\n    Convert PyTorch state dict to JAX pytree using\n    in-memory structures and field mappings.\n\n    Args:\n        jax_fields (list[JaxField]): List of JAX fields.\n        torch_fields (list[TorchField]): List of PyTorch fields.\n        pytree (PyTree): The target JAX pytree structure.\n        state_dict (dict[str, np.ndarray]): The source PyTorch state dict.\n\n    Returns:\n        tuple: A tuple containing the converted pytree and its associated state.\n\n    Raises:\n        ValueError: If fields have incompatible shapes.\n    \"\"\"\n    identity = lambda *args, **kwargs: pytree\n    model, state = eqx.nn.make_with_state(identity)()\n    state_paths: list[tuple[JaxField, TorchField]] = []\n    for i in range(len(jax_fields)):\n        torch_field = torch_fields[i]\n        jax_field = jax_fields[i]\n        if torch_field.skip:\n            continue\n        if not can_reshape(jax_field.shape, torch_field.shape):\n            raise ValueError(\n                \"Fields have incompatible shapes! \"\n                f\"{jax_field.shape=} != {torch_field.shape=}\"\n            )\n        path = jax_field.path.split(\".\")[1:]\n        if \"StateIndex\" in jax_field.type:\n            state_paths.append((jax_field, torch_field))\n\n        else:\n            where = ft.partial(get_node, targets=path)\n            if where(model) is not None:\n                model = eqx.tree_at(\n                    where,\n                    model,\n                    state_dict[torch_field.path].reshape(jax_field.shape),\n                )\n    result: dict[str, list[TorchField]] = {}\n    for tuple_item in state_paths:\n        path_prefix = tuple_item[0].path.split(\".\")[1:-1]\n        prefix_key = \".\".join(path_prefix)\n        if prefix_key not in result:\n            result[prefix_key] = []\n        result[prefix_key].append(tuple_item[1])\n\n    for key in result:\n        state_index = get_node(model, key.split(\".\"))\n        if state_index is not None:\n            to_replace_tuple = tuple([state_dict[i.path] for i in result[key]])\n            state = state.set(state_index, to_replace_tuple)\n    return model, state\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.index","title":"<code>index()</code>","text":"<p>Serve the index.html file from the client's public directory.</p> <p>Returns:</p> Type Description <p>The contents of index.html file.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>@app.route(\"/\", methods=[\"GET\"])\ndef index():\n    \"\"\"\n    Serve the index.html file from the client's public directory.\n\n    Returns:\n        The contents of index.html file.\n    \"\"\"\n    return flask.send_from_directory(\"../client/public\", \"index.html\")\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.make_anthropic_request","title":"<code>make_anthropic_request()</code>","text":"<p>Make a request to the Anthropic API using the provided content and model.</p> <p>Returns:</p> Type Description <p>flask.Response: JSON response containing the API response or an error message.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If required keys are missing in the request data.</p> Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>@app.post(\"/anthropic\")\ndef make_anthropic_request():\n    \"\"\"\n    Make a request to the Anthropic API using the provided content and model.\n\n    Returns:\n        flask.Response: JSON response containing the API response or an error message.\n\n    Raises:\n        KeyError: If required keys are missing in the request data.\n    \"\"\"\n    api_key = os.getenv(\"ANTHROPIC_API_KEY\", None)\n    if api_key is None:\n        return {\"error\": \"ANTHROPIC_API_KEY not set in env vars!\"}\n\n    request_data = flask.request.json\n    if request_data is None:\n        return flask.jsonify({\"error\": \"No data received\"})\n    if \"content\" not in request_data:\n        return flask.jsonify({\"error\": \"No data received\"})\n\n    if \"model\" not in request_data:\n        return flask.jsonify({\"error\": \"There was no model provided\"})\n\n    content = request_data[\"content\"]\n\n    anthropic_model: Optional[str] = None\n\n    match request_data[\"model\"]:\n        case \"haiku\":\n            anthropic_model = \"claude-3-haiku-20240307\"\n        case \"opus\":\n            anthropic_model = \"claude-3-opus-20240229\"\n        case \"sonnet\":\n            anthropic_model = \"claude-3-sonnet-20240229\"\n    if not anthropic_model:\n        return flask.jsonify({\"error\": \"No model provided\"})\n\n    client = anthropic.Anthropic(api_key=api_key)\n    message = client.messages.create(\n        model=anthropic_model,\n        max_tokens=4096,\n        messages=[{\"role\": \"user\", \"content\": content}],\n    )\n\n    return json.dumps({\"content\": str(message.content[0].text)})  # pyright: ignore\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.start_conversion_from_paths","title":"<code>start_conversion_from_paths(pytree_path, state_dict_path)</code>","text":"<p>Initialize the conversion process using file paths and start the Flask server.</p> <p>Parameters:</p> Name Type Description Default <code>pytree_path</code> <code>str</code> <p>Path to the JAX pytree directory.</p> required <code>state_dict_path</code> <code>str</code> <p>Path to the PyTorch state dict directory.</p> required Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def start_conversion_from_paths(pytree_path: str, state_dict_path: str):\n    \"\"\"\n    Initialize the conversion process using file paths and start the Flask server.\n\n    Args:\n        pytree_path (str): Path to the JAX pytree directory.\n        state_dict_path (str): Path to the PyTorch state dict directory.\n    \"\"\"\n    global PYTREE_PATH, STATE_DICT_PATH\n    PYTREE_PATH = ChunkifiedPytreePath(path=pytree_path)\n    STATE_DICT_PATH = ChunkifiedStatedictPath(path=state_dict_path)\n    _run_server()\n</code></pre>"},{"location":"statedict2pytree/#statedict2pytree.statedict2pytree.start_conversion_from_pytree_and_state_dict","title":"<code>start_conversion_from_pytree_and_state_dict(pytree, state_dict)</code>","text":"<p>Initialize the conversion process using in-memory structures and start the Flask server.</p> <p>Parameters:</p> Name Type Description Default <code>pytree</code> <code>PyTree</code> <p>The target JAX pytree structure.</p> required <code>state_dict</code> <code>dict[str, Tensor]</code> <p>The source PyTorch state dict.</p> required Source code in <code>statedict2pytree/statedict2pytree.py</code> <pre><code>def start_conversion_from_pytree_and_state_dict(\n    pytree: PyTree, state_dict: dict[str, torch.Tensor]\n):\n    \"\"\"\n    Initialize the conversion process using in-memory structures and\n    start the Flask server.\n\n    Args:\n        pytree (PyTree): The target JAX pytree structure.\n        state_dict (dict[str, torch.Tensor]): The source PyTorch state dict.\n    \"\"\"\n    global PYTREE, STATE_DICT\n    PYTREE = pytree\n    STATE_DICT = dict()\n\n    for k, v in state_dict.items():\n        STATE_DICT[k] = v.numpy()\n    _run_server()\n</code></pre>"},{"location":"utils/","title":"Utils","text":""},{"location":"utils/#pytree-utils","title":"PyTree Utils","text":""},{"location":"utils/#statedict2pytree.utils.utils_pytree.chunkify_pytree","title":"<code>chunkify_pytree(tree, target_path)</code>","text":"<p>Convert a JAX PyTree into chunked files and save them to the specified path.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>PyTree</code> <p>The JAX PyTree to be chunked.</p> required <code>target_path</code> <code>str</code> <p>The directory where chunked files will be saved.</p> required <p>Returns:</p> Type Description <code>list[ChunkifiedPytreePath]</code> <p>list[ChunkifiedPytreePath]: A list of paths to the chunked files.</p> <p>This function also saves JaxFields as a pickle file in the target directory.</p> Source code in <code>statedict2pytree/utils/utils_pytree.py</code> <pre><code>def chunkify_pytree(tree: PyTree, target_path: str) -&gt; list[ChunkifiedPytreePath]:\n    \"\"\"\n    Convert a JAX PyTree into chunked files and save them to the specified path.\n\n    Args:\n        tree (PyTree): The JAX PyTree to be chunked.\n        target_path (str): The directory where chunked files will be saved.\n\n    Returns:\n        list[ChunkifiedPytreePath]: A list of paths to the chunked files.\n\n    This function also saves JaxFields as a pickle file in the target directory.\n    \"\"\"\n    paths: list[ChunkifiedPytreePath] = []\n\n    flattened, _ = jax.tree_util.tree_flatten_with_path(tree)\n\n    for key_path, value in tqdm(flattened):\n        key = jax.tree_util.keystr(key_path)\n        if not hasattr(value, \"shape\"):\n            continue\n        path = pathlib.Path(target_path) / \"pytree\"\n\n        if not os.path.exists(path):\n            os.mkdir(path)\n\n        np.save(path / key, np.array(value))\n        paths.append(ChunkifiedPytreePath(path=str(path / key)))\n\n    jax_fields = pytree_to_fields(tree)\n    with open(pathlib.Path(target_path) / \"jax_fields.pkl\", \"wb\") as f:\n        pickle.dump(jax_fields, f)\n\n    return paths\n</code></pre>"},{"location":"utils/#statedict2pytree.utils.utils_pytree.get_node","title":"<code>get_node(tree, targets)</code>","text":"<p>Retrieve a node from the PyTree based on the given path.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>PyTree</code> <p>The PyTree to search.</p> required <code>targets</code> <code>list[str]</code> <p>Path to the target node.</p> required <p>Returns:</p> Type Description <code>PyTree | None</code> <p>PyTree | None: The target node if found, None otherwise.</p> <p>Examples: <pre><code>import equinox as eqx\n\nclass MyModel(eqx.Module):\n    layer1: eqx.nn.Linear\n    layer2: eqx.nn.Linear\n\nmodel = MyModel(\n        layer1=eqx.nn.Linear(10, 20, key=jax.random.key(0)),\n        layer2=eqx.nn.Linear(20, 5, key=jax.random.key(1)),\n    )\nlayer1_weight = get_node(model, ['layer1', 'weight'])\nassert layer1_weight.shape == (20, 10)\nnonexistent_node = get_node(model, ['layer3'])\nassert nonexistent_node is None\n</code></pre></p> Source code in <code>statedict2pytree/utils/utils_pytree.py</code> <pre><code>def get_node(tree: PyTree, targets: list[str]) -&gt; PyTree | None:\n    \"\"\"\n    Retrieve a node from the PyTree based on the given path.\n\n    Args:\n        tree (PyTree): The PyTree to search.\n        targets (list[str]): Path to the target node.\n\n    Returns:\n        PyTree | None: The target node if found, None otherwise.\n\n    Examples:\n    ```python\n    import equinox as eqx\n\n    class MyModel(eqx.Module):\n        layer1: eqx.nn.Linear\n        layer2: eqx.nn.Linear\n\n    model = MyModel(\n            layer1=eqx.nn.Linear(10, 20, key=jax.random.key(0)),\n            layer2=eqx.nn.Linear(20, 5, key=jax.random.key(1)),\n        )\n    layer1_weight = get_node(model, ['layer1', 'weight'])\n    assert layer1_weight.shape == (20, 10)\n    nonexistent_node = get_node(model, ['layer3'])\n    assert nonexistent_node is None\n    ```\n    \"\"\"\n    if len(targets) == 0 or tree is None:\n        return tree\n    else:\n        next_target: str = targets[0]\n        if bool(re.search(r\"\\[\\d+\\]\", next_target)):\n            split_index = next_target.rfind(\"[\")\n            name, index = next_target[:split_index], next_target[split_index:]\n            index = index[1:-1]\n            if hasattr(tree, name):\n                subtree = getattr(tree, name)[int(index)]\n            else:\n                subtree = None\n        else:\n            if hasattr(tree, next_target):\n                subtree = getattr(tree, next_target)\n            else:\n                subtree = None\n        return get_node(subtree, targets[1:])\n</code></pre>"},{"location":"utils/#statedict2pytree.utils.utils_pytree.pytree_to_fields","title":"<code>pytree_to_fields(pytree)</code>","text":"<p>Convert a JAX PyTree to a list of JaxField objects.</p> <p>Parameters:</p> Name Type Description Default <code>pytree</code> <code>PyTree</code> <p>The JAX PyTree to be converted.</p> required <p>Returns:</p> Type Description <code>list[JaxField]</code> <p>list[JaxField]: A list of JaxField objects representing the PyTree.</p> Source code in <code>statedict2pytree/utils/utils_pytree.py</code> <pre><code>def pytree_to_fields(pytree: PyTree) -&gt; list[JaxField]:\n    \"\"\"\n    Convert a JAX PyTree to a list of JaxField objects.\n\n    Args:\n        pytree (PyTree): The JAX PyTree to be converted.\n\n    Returns:\n        list[JaxField]: A list of JaxField objects representing the PyTree.\n    \"\"\"\n    flattened, _ = jax.tree_util.tree_flatten_with_path(pytree)\n    fields = []\n    for key_path, value in flattened:\n        path = jax.tree_util.keystr(key_path)\n        type_path = path.split(\".\")[1:-1]\n        target_path = path.split(\".\")[1:]\n        node_type = type(get_node(pytree, type_path))\n        node = get_node(pytree, target_path)\n        if node is not None and hasattr(node, \"shape\") and len(node.shape) &gt; 0:\n            fields.append(\n                JaxField(path=path, type=str(node_type), shape=tuple(node.shape))\n            )\n\n    return fields\n</code></pre>"},{"location":"utils/#statedict2pytree.utils.utils_pytree.replace_node","title":"<code>replace_node(tree, targets, new_value)</code>","text":"<p>Replace a node in the PyTree with a new value.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>PyTree</code> <p>The PyTree to modify.</p> required <code>targets</code> <code>list[str]</code> <p>Path to the target node.</p> required <code>new_value</code> <code>Array</code> <p>The new value to insert.</p> required <p>Returns:</p> Name Type Description <code>PyTree</code> <code>PyTree</code> <p>The modified PyTree.</p> <p>Examples: <pre><code>import equinox as eqx\n\nclass MyModel(eqx.Module):\n    layer1: eqx.nn.Linear\n    layer2: eqx.nn.Linear\n\nmodel = MyModel(\n    layer1=eqx.nn.Linear(10, 20, key=jax.random.key(0)),\n    layer2=eqx.nn.Linear(20, 5, key=jax.random.key(1)),\n)\nnew_weight = jax.numpy.ones((20, 10))\nupdated_model = replace_node(\n                    model,\n                    ['layer1', 'weight'],\n                    new_weight\n                )\nassert (updated_model.layer1.weight == new_weight).all()\n</code></pre></p> Source code in <code>statedict2pytree/utils/utils_pytree.py</code> <pre><code>def replace_node(tree: PyTree, targets: list[str], new_value: Array) -&gt; PyTree:\n    \"\"\"\n    Replace a node in the PyTree with a new value.\n\n    Args:\n        tree (PyTree): The PyTree to modify.\n        targets (list[str]): Path to the target node.\n        new_value (Array): The new value to insert.\n\n    Returns:\n        PyTree: The modified PyTree.\n\n    Examples:\n    ```python\n    import equinox as eqx\n\n    class MyModel(eqx.Module):\n        layer1: eqx.nn.Linear\n        layer2: eqx.nn.Linear\n\n    model = MyModel(\n        layer1=eqx.nn.Linear(10, 20, key=jax.random.key(0)),\n        layer2=eqx.nn.Linear(20, 5, key=jax.random.key(1)),\n    )\n    new_weight = jax.numpy.ones((20, 10))\n    updated_model = replace_node(\n                        model,\n                        ['layer1', 'weight'],\n                        new_weight\n                    )\n    assert (updated_model.layer1.weight == new_weight).all()\n    ```\n    \"\"\"\n    where = ft.partial(get_node, targets=targets)\n    node = where(tree)\n\n    if node is not None and hasattr(node, \"shape\"):\n        tree = eqx.tree_at(\n            where,\n            tree,\n            new_value.reshape(node.shape),\n        )\n    else:\n        print(\"Couldn't find: \", targets)\n    return tree\n</code></pre>"},{"location":"utils/#statedict2pytree.utils.utils_pytree.serialize_pytree_chunks","title":"<code>serialize_pytree_chunks(tree, paths, name)</code>","text":"<p>Reassemble a JAX PyTree from chunked files and serialize it.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>PyTree</code> <p>The original JAX PyTree structure.</p> required <code>paths</code> <code>list[ChunkifiedPytreePath]</code> <p>List of paths to the chunked files.</p> required <code>name</code> <code>str</code> <p>Name of the output serialized file.</p> required Source code in <code>statedict2pytree/utils/utils_pytree.py</code> <pre><code>def serialize_pytree_chunks(tree: PyTree, paths: list[ChunkifiedPytreePath], name: str):\n    \"\"\"\n    Reassemble a JAX PyTree from chunked files and serialize it.\n\n    Args:\n        tree (PyTree): The original JAX PyTree structure.\n        paths (list[ChunkifiedPytreePath]): List of paths to the chunked files.\n        name (str): Name of the output serialized file.\n    \"\"\"\n    for chunk_path in tqdm(paths):\n        array = np.load(chunk_path.path)\n        tree = replace_node(tree, chunk_path.path.split(\".\")[1:-1], array)\n\n    identity = lambda *args, **kwargs: tree\n    model, state = eqx.nn.make_with_state(identity)()\n    eqx.tree_serialise_leaves(name, (model, state))\n</code></pre>"},{"location":"utils/#state-dict-utils","title":"State Dict Utils","text":""},{"location":"utils/#statedict2pytree.utils.utils_state_dict.chunkify_state_dict","title":"<code>chunkify_state_dict(state_dict, target_path)</code>","text":"<p>Convert a PyTorch state dict into chunked files and save them to the specified path.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>dict[str, ndarray]</code> <p>The PyTorch state dict to be chunked.</p> required <code>target_path</code> <code>str</code> <p>The directory where chunked files will be saved.</p> required <p>Returns:</p> Type Description <code>list[ChunkifiedStatedictPath]</code> <p>list[ChunkifiedStatedictPath]: A list of paths to the chunked files.</p> <p>This function also saves TorchFields as a pickle file in the target directory.</p> Source code in <code>statedict2pytree/utils/utils_state_dict.py</code> <pre><code>def chunkify_state_dict(\n    state_dict: dict[str, np.ndarray], target_path: str\n) -&gt; list[ChunkifiedStatedictPath]:\n    \"\"\"\n    Convert a PyTorch state dict into chunked files and save them to the specified path.\n\n    Args:\n        state_dict (dict[str, np.ndarray]): The PyTorch state dict to be chunked.\n        target_path (str): The directory where chunked files will be saved.\n\n    Returns:\n        list[ChunkifiedStatedictPath]: A list of paths to the chunked files.\n\n    This function also saves TorchFields as a pickle file in the target directory.\n    \"\"\"\n    paths = []\n\n    for key in tqdm(state_dict.keys()):\n        if not hasattr(state_dict[key], \"shape\"):\n            continue\n        path = pathlib.Path(target_path) / \"state_dict\"\n\n        if not os.path.exists(path):\n            os.mkdir(path)\n\n        np.save(path / key, state_dict[key])\n        paths.append(ChunkifiedStatedictPath(path=str(path / key)))\n\n    torch_fields = state_dict_to_fields(state_dict)\n    with open(pathlib.Path(target_path) / \"torch_fields.pkl\", \"wb\") as f:\n        pickle.dump(torch_fields, f)\n    return paths\n</code></pre>"},{"location":"utils/#statedict2pytree.utils.utils_state_dict.state_dict_to_fields","title":"<code>state_dict_to_fields(state_dict)</code>","text":"<p>Convert a PyTorch state dict to a list of TorchField objects.</p> <p>Parameters:</p> Name Type Description Default <code>state_dict</code> <code>Optional[dict]</code> <p>The PyTorch state dict to be converted.</p> required <p>Returns:</p> Type Description <code>list[TorchField]</code> <p>list[TorchField]: A list of TorchField objects representing the state dict.</p> Source code in <code>statedict2pytree/utils/utils_state_dict.py</code> <pre><code>def state_dict_to_fields(state_dict: Optional[dict]) -&gt; list[TorchField]:\n    \"\"\"\n    Convert a PyTorch state dict to a list of TorchField objects.\n\n    Args:\n        state_dict (Optional[dict]): The PyTorch state dict to be converted.\n\n    Returns:\n        list[TorchField]: A list of TorchField objects representing the state dict.\n    \"\"\"\n    if state_dict is None:\n        return []\n    fields: list[TorchField] = []\n    for key, value in state_dict.items():\n        if hasattr(value, \"shape\") and len(value.shape) &gt; 0:\n            fields.append(TorchField(path=key, shape=tuple(value.shape)))\n    return fields\n</code></pre>"},{"location":"utils/#other-utils","title":"Other Utils","text":""},{"location":"utils/#statedict2pytree.utils.utils.can_reshape","title":"<code>can_reshape(shape1, shape2)</code>","text":"<p>Check if two shapes can be reshaped to each other.</p> <p>Parameters:</p> Name Type Description Default <code>shape1</code> <code>tuple</code> <p>First shape.</p> required <code>shape2</code> <code>tuple</code> <p>Second shape.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if shapes can be reshaped to each other, False otherwise.</p> Source code in <code>statedict2pytree/utils/utils.py</code> <pre><code>def can_reshape(shape1: tuple, shape2: tuple):\n    \"\"\"\n    Check if two shapes can be reshaped to each other.\n\n    Args:\n        shape1 (tuple): First shape.\n        shape2 (tuple): Second shape.\n\n    Returns:\n        bool: True if shapes can be reshaped to each other, False otherwise.\n    \"\"\"\n    product1 = np.prod(shape1)\n    product2 = np.prod(shape2)\n\n    return product1 == product2\n</code></pre>"},{"location":"utils/#statedict2pytree.utils.utils.field_jsons_to_fields","title":"<code>field_jsons_to_fields(jax_fields_json, torch_fields_json)</code>","text":"<p>Convert JSON representations of JAX and PyTorch fields to JaxField and TorchField objects.</p> <p>Parameters:</p> Name Type Description Default <code>jax_fields_json</code> <p>JSON representation of JAX fields.</p> required <code>torch_fields_json</code> <p>JSON representation of PyTorch fields.</p> required <p>Returns:</p> Type Description <code>list[JaxField]</code> <p>tuple[list[JaxField], list[TorchField]]: A tuple containing lists of</p> <code>list[TorchField]</code> <p>JaxField and TorchField objects.</p> Source code in <code>statedict2pytree/utils/utils.py</code> <pre><code>def field_jsons_to_fields(\n    jax_fields_json, torch_fields_json\n) -&gt; tuple[list[JaxField], list[TorchField]]:\n    \"\"\"\n    Convert JSON representations of JAX and PyTorch fields to\n    JaxField and TorchField objects.\n\n    Args:\n        jax_fields_json: JSON representation of JAX fields.\n        torch_fields_json: JSON representation of PyTorch fields.\n\n    Returns:\n        tuple[list[JaxField], list[TorchField]]: A tuple containing lists of\n        JaxField and TorchField objects.\n    \"\"\"\n    jax_fields: list[JaxField] = []\n    for f in jax_fields_json:\n        jax_fields.append(\n            JaxField(path=f[\"path\"], type=f[\"type\"], shape=tuple(f[\"shape\"]))\n        )\n\n    torch_fields: list[TorchField] = []\n    for f in torch_fields_json:\n        torch_fields.append(\n            TorchField(path=f[\"path\"], shape=tuple(f[\"shape\"]), skip=f[\"skip\"])\n        )\n    return jax_fields, torch_fields\n</code></pre>"}]}