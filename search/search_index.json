{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Quickstart Guide","text":""},{"location":"#installation","title":"Installation","text":"<p>To install <code>statedict2pytree</code>, run:</p> <pre><code>pip install statedict2pytree\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>There are 4-5 main functions you might interact with:</p> <ul> <li><code>autoconvert</code></li> <li><code>convert</code></li> <li><code>pytree_to_fields</code></li> <li><code>state_dict_to_fields</code></li> <li><code>move_running_fields_to_the_end</code> (optional helper)</li> </ul>"},{"location":"#general-information","title":"General Information","text":"<p><code>statedict2pytree</code> primarily aligns your JAX PyTree and the PyTorch <code>state_dict</code> side-by-side. It then checks if the shapes of the aligned weights match. If they do, it converts the PyTorch tensors to JAX arrays and places them into a new PyTree with the same structure as your original JAX PyTree.</p> <p>This means that the order and the shape of the arrays in your PyTree and the <code>state_dict</code> must match after any optional reordering! The <code>pytree_to_fields</code> function uses a filter (defaulting to <code>equinox.is_array</code>) to determine which elements are considered fields.</p> <p>For example, this conversion will work \u2705:</p> Parameter JAX Shape PyTorch Shape <code>linear.weight</code> <code>(2, 2)</code> <code>(2, 2)</code> <code>linear.bias</code> <code>(2,)</code> <code>(2,)</code> <code>conv.weight</code> <code>(1, 1, 2, 2)</code> <code>(1, 1, 2, 2)</code> <code>conv.bias</code> <code>(1,)</code> <code>(1,)</code> <p>Since the shapes match when aligned in the same order, the conversion is successful.</p> <p>On the other hand, this will not work \u274c:</p> Parameter JAX Shape PyTorch Shape Mismatch? <code>linear.weight</code> <code>(2, 2)</code> <code>(3, 2)</code> Yes <code>linear.bias</code> <code>(2,)</code> <code>(3,)</code> Yes <code>conv.weight</code> <code>(1, 1, 2, 2)</code> <code>(1, 1, 2, 2)</code> No <code>conv.bias</code> <code>(1,)</code> <code>(1,)</code> No <p>This conversion will fail because the shapes of <code>model.linear.weight</code> and <code>model.linear.bias</code> don't match between the PyTree and the state dict.</p> <p>Another reason why the conversion might fail is if the order of parameters (and thus the shapes of misaligned parameters) doesn't match:</p> JAX Parameter (Model Order) JAX Shape PyTorch Counterpart (<code>state_dict</code> Order) PyTorch Shape Issue if Matched Sequentially <code>model['conv']['weight']</code> <code>(1, 1, 2, 2)</code> <code>state_dict['model.linear.weight']</code> <code>(2, 2)</code> Order: JAX <code>conv.w</code> <code>(1122)</code> vs PT <code>linear.w</code> <code>(22)</code> <code>model['conv']['bias']</code> <code>(1,)</code> <code>state_dict['model.linear.bias']</code> <code>(2,)</code> Order: JAX <code>conv.b</code> <code>(1,)</code> vs PT <code>linear.b</code> <code>(2,)</code> <code>model['linear']['weight']</code> <code>(2, 2)</code> <code>state_dict['model.conv.weight']</code> <code>(1, 1, 2, 2)</code> Order: JAX <code>linear.w</code> <code>(22)</code> vs PT <code>conv.w</code> <code>(1122)</code> <code>model['linear']['bias']</code> <code>(2,)</code> <code>state_dict['model.conv.bias']</code> <code>(1,)</code> Order: JAX <code>linear.b</code> <code>(2,)</code> vs PT <code>conv.b</code> <code>(1,)</code> <p>To help with the order issue, you can provide a <code>list[str]</code> specifying the desired order of PyTree fields (matching the <code>state_dict</code>'s conceptual order, or vice-versa if you reorder <code>state_dict</code> fields). This is especially helpful when you can't easily force the correct order using <code>move_running_fields_to_the_end</code>. For the example above, if your PyTree expects <code>conv</code> then <code>linear</code>, the list of strings representing the names from the state_dict in the JAX PyTree's desired order would be:</p> <p><pre><code>['model.conv.weight', 'model.conv.bias', 'model.linear.weight', 'model.linear.bias']\n</code></pre> This list would be passed to <code>pytree_to_fields</code> via <code>autoconvert</code>'s <code>pytree_model_order</code> argument to ensure <code>jaxfields</code> are in this sequence. Alternatively, you could reorder <code>torchfields</code> using <code>move_running_fields_to_the_end</code> or other custom logic.</p>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#autoconvert","title":"<code>autoconvert</code>","text":"<p>This is the simplest, highest-level function for most use cases.</p> <pre><code>def autoconvert(\n    pytree: PyTree,\n    state_dict: dict,\n    pytree_model_order: list[str] | None = None\n) -&gt; PyTree:\n    ...\n</code></pre> <p>You provide your JAX <code>pytree</code> and the PyTorch <code>state_dict</code>. Optionally, you can give <code>pytree_model_order</code> (a list of strings representing <code>jax.tree_util.keystr(path)</code>) to ensure the JAX fields are processed in a specific sequence. It handles the steps of field extraction (using <code>pytree_to_fields</code> with its default <code>filter=eqx.is_array</code>), alignment, and conversion, returning the populated JAX PyTree. If you need custom filtering for PyTree leaves, you should use <code>pytree_to_fields</code> and <code>convert</code> separately.</p> <ul> <li>Parameters:<ul> <li><code>pytree</code>: The JAX PyTree (e.g., an Equinox model) whose structure is the target.</li> <li><code>state_dict</code>: The PyTorch state dictionary containing the weights.</li> <li><code>pytree_model_order</code> (optional): A list of JAX KeyPath strings (like <code>'.layers.0.linear.weight'</code>). If provided, JAX fields will be ordered according to this list. This is useful if the automatic PyTree traversal order doesn't match the <code>state_dict</code> order.</li> </ul> </li> <li>Returns: A new JAX PyTree with the same structure as the input <code>pytree</code>, but with weights populated from the <code>state_dict</code>.</li> </ul>"},{"location":"#convert","title":"<code>convert</code>","text":"<p>This is the core function that performs the actual conversion once the JAX PyTree fields and PyTorch <code>state_dict</code> fields have been extracted and aligned.</p> <pre><code>def convert(\n    state_dict: dict[str, Any],\n    pytree: PyTree,\n    jaxfields: list[JaxField],\n    state_indices: dict | None,\n    torchfields: list[TorchField],\n    dtype: Any | None = None,\n) -&gt; PyTree:\n    ...\n</code></pre> <p>It iterates through the aligned <code>jaxfields</code> and <code>torchfields</code>, checks for shape compatibility (reshapability), converts PyTorch tensors (expected as values in <code>state_dict</code>) to JAX arrays (optionally casting <code>dtype</code>), and inserts them into the correct place in the JAX PyTree.</p> <ul> <li>Parameters:<ul> <li><code>state_dict</code>: The original PyTorch state dictionary. Values are expected to be tensor-like (e.g., <code>torch.Tensor</code>).</li> <li><code>pytree</code>: The JAX PyTree that will be populated.</li> <li><code>jaxfields</code>: An ordered list of <code>JaxField</code> objects (obtained from <code>pytree_to_fields</code>) representing the leaves of the JAX PyTree.</li> <li><code>state_indices</code>: A dictionary mapping state markers to <code>eqx.nn.StateIndex</code> objects, used for handling Equinox stateful layers.</li> <li><code>torchfields</code>: An ordered list of <code>TorchField</code> objects (obtained from <code>state_dict_to_fields</code>) representing the tensors in the PyTorch <code>state_dict</code>. This list must be ordered to match <code>jaxfields</code>.</li> <li><code>dtype</code> (optional): The JAX data type to convert floating-point tensors to (e.g., <code>jnp.float32</code>). Defaults to JAX's current default floating-point type.</li> </ul> </li> <li>Returns: A new JAX PyTree populated with weights from the <code>state_dict</code>.</li> </ul>"},{"location":"#pytree_to_fields","title":"<code>pytree_to_fields</code>","text":"<p>This function traverses a JAX PyTree and extracts information about its array leaves based on a filter.</p> <pre><code>def pytree_to_fields(\n    pytree: PyTree,\n    model_order: list[str] | None = None,\n    filter: Callable[[Array], bool] = eqx.is_array,\n) -&gt; tuple[list[JaxField], dict | None]:\n    ...\n</code></pre> <p>It identifies all JAX arrays (or other elements satisfying the <code>filter</code>) within the <code>pytree</code>, recording their <code>KeyPath</code> (path within the PyTree) and shape. If <code>model_order</code> is provided, it attempts to reorder the extracted fields according to that list. This is crucial for ensuring the JAX fields align correctly with the PyTorch fields.</p> <ul> <li>Parameters:<ul> <li><code>pytree</code>: The JAX PyTree to analyze.</li> <li><code>model_order</code> (optional): A list of strings, where each string is a <code>jax.tree_util.keystr</code> representation of a <code>KeyPath</code> to an array leaf in the <code>pytree</code>. If provided, the output <code>JaxField</code> list will be sorted according to this order, with any fields not in <code>model_order</code> appended at the end.</li> <li><code>filter</code> (optional): A callable that takes a PyTree leaf (e.g., an array) and returns <code>True</code> if it should be considered a field to be converted, <code>False</code> otherwise. Defaults to <code>equinox.is_array</code>.</li> </ul> </li> <li>Returns: A tuple containing:<ul> <li><code>list[JaxField]</code>: A list of <code>JaxField</code> objects, each describing a filtered leaf in the PyTree (path, shape).</li> <li><code>dict | None</code>: A dictionary containing information about <code>eqx.nn.StateIndex</code> objects found in the PyTree, or <code>None</code> if none are found.</li> </ul> </li> </ul>"},{"location":"#state_dict_to_fields","title":"<code>state_dict_to_fields</code>","text":"<p>This function processes a PyTorch <code>state_dict</code> to extract information about its tensors.</p> <pre><code>def state_dict_to_fields(\n    state_dict: dict[str, Any],\n) -&gt; list[TorchField]:\n    ...\n</code></pre> <p>It iterates through the <code>state_dict</code>, creating a <code>TorchField</code> object for each value that has a <code>shape</code> attribute and a non-empty shape (typically tensors). This object stores the tensor's name (key in the <code>state_dict</code>) and its shape.</p> <ul> <li>Parameters:<ul> <li><code>state_dict</code>: The PyTorch state dictionary. Values are typically <code>torch.Tensor</code> or other array-like objects.</li> </ul> </li> <li>Returns: A list of <code>TorchField</code> objects, each describing a tensor in the <code>state_dict</code> (path/key, shape). The order matches the iteration order of the input <code>state_dict</code>.</li> </ul>"},{"location":"#move_running_fields_to_the_end","title":"<code>move_running_fields_to_the_end</code>","text":"<p>This is an optional utility function to help reorder fields extracted from a PyTorch <code>state_dict</code>.</p> <pre><code>def move_running_fields_to_the_end(\n    torchfields: list[TorchField],\n    identifier: str = \"running_\"\n):\n    ...\n</code></pre> <p>It's particularly useful for models with layers like <code>BatchNorm</code>, where PyTorch often stores <code>running_mean</code> and <code>running_var</code> interspersed with weights and biases, while Equinox (a common JAX library) typically expects stateful components like these at the end of a layer's parameter list. This function moves any <code>TorchField</code> whose path contains the <code>identifier</code> (defaulting to <code>\"running_\"</code>) to the end of the list.</p> <ul> <li>Parameters:<ul> <li><code>torchfields</code>: The list of <code>TorchField</code> objects to be reordered.</li> <li><code>identifier</code> (optional): A string that, if found within a <code>TorchField</code>'s path, will cause that field to be moved to the end of the list. Default is <code>\"running_\"</code>.</li> </ul> </li> <li>Returns: The modified list of <code>TorchField</code> objects with identified fields moved to the end.</li> </ul>"}]}